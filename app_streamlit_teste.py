# -*- coding: utf-8 -*-
# Dashboard de √≠ndices econ√¥micos brasileiros
# Autor: Lucas Magalh√£es

import streamlit as st
import pandas as pd
import altair as alt
import ipeadatapy as ipea

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Dashboard de √çndices Econ√¥micos",
    page_icon=":bar_chart:",
    layout="wide",
)

"""
# :bar_chart: Dashboard de √çndices Econ√¥micos Brasileiros

Compare a evolu√ß√£o de diferentes √≠ndices de infla√ß√£o, juros e pre√ßos ao longo do tempo.
"""

# --- Dicion√°rio de √≠ndices dispon√≠veis ---
indices = {
    "IPCA": "PRECOS12_IPCAG12",
    "IGP-M": "IGP12_IGPMG12",
    "INPC": "PRECOS12_INPCBR12",
    "SELIC (Over)": "BM12_TJOVER12",
    "IPC-FIPE": "FIPE12_FIPE0001",
    "IGP-DI": "IGP12_IGPDIG12",
}

DEFAULT_INDICES = ["IPCA", "IGP-M", "INPC"]

# --- Fun√ß√£o para carregar s√©ries ---
@st.cache_data(show_spinner=True)
def carregar_series(indices):
    dados = {}
    for nome, codigo in indices.items():
        try:
            serie = ipea.timeseries(codigo)
            serie = serie.rename(columns={"VALUE ((% a.m.))": "valor"})
            serie = serie[["valor"]].dropna()
            dados[nome] = serie
        except Exception as e:
            st.warning(f"Erro ao carregar {nome}: {e}")
    return dados

dados_indices = carregar_series(indices)

# --- Seletor de √≠ndices ---
indices_escolhidos = st.multiselect(
    "Escolha os √≠ndices para comparar:",
    options=list(indices.keys()),
    default=DEFAULT_INDICES,
)

if not indices_escolhidos:
    st.info("Selecione ao menos um √≠ndice para continuar.")
    st.stop()

# --- Filtro de datas ---
todas_datas = pd.concat([dados_indices[i] for i in indices_escolhidos]).index
data_min = todas_datas.min().to_pydatetime()
data_max = todas_datas.max().to_pydatetime()

periodo = st.slider(
    "Selecione o per√≠odo de an√°lise:",
    min_value=data_min,
    max_value=data_max,
    value=(data_min, data_max),
    format="MM/YYYY"
)

# --- Preparar dados para gr√°fico ---
df_comb = pd.DataFrame()
for nome in indices_escolhidos:
    serie = dados_indices[nome].loc[periodo[0]:periodo[1]]
    serie["√çndice"] = nome
    df_comb = pd.concat([df_comb, serie])

# --- Normalizar as s√©ries para compara√ß√£o ---
df_comb["valor_norm"] = df_comb.groupby("√çndice")["valor"].apply(
    lambda x: x / x.iloc[0]
)

# --- Gr√°fico de compara√ß√£o ---
st.subheader("üìà Evolu√ß√£o comparativa (valores normalizados)")
chart = (
    alt.Chart(df_comb.reset_index())
    .mark_line()
    .encode(
        x=alt.X("DATE:T", title="Data"),
        y=alt.Y("valor_norm:Q", title="Valor Normalizado"),
        color="√çndice:N",
        tooltip=["DATE:T", "√çndice:N", "valor:Q"]
    )
    .properties(height=400)
)
st.altair_chart(chart, use_container_width=True)

# --- Estat√≠sticas simples ---
st.subheader("üìä Estat√≠sticas do per√≠odo selecionado")
for nome in indices_escolhidos:
    serie = dados_indices[nome].loc[periodo[0]:periodo[1]]
    variacao = ((serie.iloc[-1]["valor"] / serie.iloc[0]["valor"]) - 1) * 100
    st.metric(nome, f"{variacao:.2f}%", delta_color="inverse")

# --- Mostrar dados brutos ---
st.subheader("üìë Dados brutos")
st.dataframe(df_comb.reset_index().rename(columns={"DATE": "Data"}))

# ============================================================
# üí∞ CORRE√á√ÉO MONET√ÅRIA (NOVA SE√á√ÉO)
# ============================================================

import ipeadatapy as ipea
from datetime import datetime

st.divider()
st.header(":money_with_wings: Corre√ß√£o Monet√°ria")

# --- dicion√°rio com os c√≥digos do IPEA ---
indices = {
    "IPCA": "PRECOS12_IPCAG12",
    "IGP-M": "IGP12_IGPMG12",
    "IGP-DI": "IGP12_IGPDIG12",
    "INPC": "PRECOS12_INPCBR12",
    "IPC-FIPE": "FIPE12_FIPE0001",
    "SELIC (Over)": "BM12_TJOVER12",
}

# --- cache dos dados para n√£o recarregar sempre ---
@st.cache_resource(show_spinner=False)
def carregar_indices():
    dados = {}
    for nome, codigo in indices.items():
        try:
            dados[nome] = ipea.timeseries(codigo)
        except Exception as e:
            st.warning(f"Erro ao carregar {nome}: {e}")
    return dados

dados_indices = carregar_indices()

# --- sele√ß√£o de √≠ndice ---
indice_escolhido = st.selectbox(
    "Selecione o √≠ndice de corre√ß√£o:",
    list(dados_indices.keys())
)

# --- entrada de dados ---
col1, col2, col3 = st.columns(3)
with col1:
    data_inicial = st.text_input("Data inicial (AAAA-MM ou MM-AAAA):")
with col2:
    data_final = st.text_input("Data final (AAAA-MM ou MM-AAAA):")
with col3:
    valor = st.number_input("Valor a corrigir (R$):", min_value=0.0, format="%.2f")

# --- fun√ß√£o auxiliar para interpretar data ---
def parse_data(data_str):
    data_str = data_str.strip()
    try:
        if "-" in data_str:
            partes = data_str.split("-")
            if len(partes[0]) == 4:  # formato AAAA-MM
                return datetime.strptime(data_str, "%Y-%m")
            else:  # formato MM-AAAA
                return datetime.strptime(data_str, "%m-%Y")
    except Exception:
        st.error("‚ö†Ô∏è Formato inv√°lido. Use AAAA-MM ou MM-AAAA.")
        return None

# --- bot√£o para calcular ---
if st.button("Calcular corre√ß√£o"):
    if not (data_inicial and data_final and valor > 0):
        st.warning("Por favor, preencha todas as informa√ß√µes.")
        st.stop()

    inicio = parse_data(data_inicial)
    fim = parse_data(data_final)

    if not (inicio and fim):
        st.stop()

    if indice_escolhido not in dados_indices:
        st.error("√çndice inv√°lido.")
        st.stop()

    serie = dados_indices[indice_escolhido].copy()
    serie = serie.rename(columns={"VALUE ((% a.m.))": "valor"})
    serie.index = pd.to_datetime(serie.index)

    inicio, fim = sorted([inicio, fim])

    serie_filtrada = serie.loc[inicio.strftime("%Y-%m"):fim.strftime("%Y-%m")]

    if serie_filtrada.empty:
        st.error("Nenhum dado encontrado nesse intervalo.")
        st.stop()

    # c√°lculo do fator acumulado
    fator = (1 + serie_filtrada["valor"] / 100).prod()
    valor_corrigido = valor * fator

    # resultado
    st.success(f"Valor corrigido de **R$ {valor:,.2f}** para **R$ {valor_corrigido:,.2f}**")
    st.write(f"Varia√ß√£o acumulada: **{(fator - 1) * 100:.2f}%** no per√≠odo.")

    # gr√°fico com Altair
    graf = (
        alt.Chart(serie_filtrada.reset_index())
        .mark_line()
        .encode(
            x=alt.X("DATE:T", title="Per√≠odo"),
            y=alt.Y("valor:Q", title=f"Varia√ß√£o mensal (%) - {indice_escolhido}"),
            tooltip=["DATE", "valor"]
        )
        .properties(title=f"Varia√ß√£o mensal do {indice_escolhido}", height=400)
    )
    st.altair_chart(graf, use_container_width=True)
